#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module Apache
  module Hadoop
    module Hbase
      module Thrift2
        module THBaseService
          class Client
            include ::Thrift::Client

            def exists(table, tget)
              send_exists(table, tget)
              return recv_exists()
            end

            def send_exists(table, tget)
              send_message('exists', Exists_args, :table => table, :tget => tget)
            end

            def recv_exists()
              result = receive_message(Exists_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'exists failed: unknown result')
            end

            def get(table, tget)
              send_get(table, tget)
              return recv_get()
            end

            def send_get(table, tget)
              send_message('get', Get_args, :table => table, :tget => tget)
            end

            def recv_get()
              result = receive_message(Get_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get failed: unknown result')
            end

            def getMultiple(table, tgets)
              send_getMultiple(table, tgets)
              return recv_getMultiple()
            end

            def send_getMultiple(table, tgets)
              send_message('getMultiple', GetMultiple_args, :table => table, :tgets => tgets)
            end

            def recv_getMultiple()
              result = receive_message(GetMultiple_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getMultiple failed: unknown result')
            end

            def put(table, tput)
              send_put(table, tput)
              recv_put()
            end

            def send_put(table, tput)
              send_message('put', Put_args, :table => table, :tput => tput)
            end

            def recv_put()
              result = receive_message(Put_result)
              raise result.io unless result.io.nil?
              return
            end

            def checkAndPut(table, row, family, qualifier, value, tput)
              send_checkAndPut(table, row, family, qualifier, value, tput)
              return recv_checkAndPut()
            end

            def send_checkAndPut(table, row, family, qualifier, value, tput)
              send_message('checkAndPut', CheckAndPut_args, :table => table, :row => row, :family => family, :qualifier => qualifier, :value => value, :tput => tput)
            end

            def recv_checkAndPut()
              result = receive_message(CheckAndPut_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'checkAndPut failed: unknown result')
            end

            def putMultiple(table, tputs)
              send_putMultiple(table, tputs)
              recv_putMultiple()
            end

            def send_putMultiple(table, tputs)
              send_message('putMultiple', PutMultiple_args, :table => table, :tputs => tputs)
            end

            def recv_putMultiple()
              result = receive_message(PutMultiple_result)
              raise result.io unless result.io.nil?
              return
            end

            def deleteSingle(table, tdelete)
              send_deleteSingle(table, tdelete)
              recv_deleteSingle()
            end

            def send_deleteSingle(table, tdelete)
              send_message('deleteSingle', DeleteSingle_args, :table => table, :tdelete => tdelete)
            end

            def recv_deleteSingle()
              result = receive_message(DeleteSingle_result)
              raise result.io unless result.io.nil?
              return
            end

            def deleteMultiple(table, tdeletes)
              send_deleteMultiple(table, tdeletes)
              return recv_deleteMultiple()
            end

            def send_deleteMultiple(table, tdeletes)
              send_message('deleteMultiple', DeleteMultiple_args, :table => table, :tdeletes => tdeletes)
            end

            def recv_deleteMultiple()
              result = receive_message(DeleteMultiple_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'deleteMultiple failed: unknown result')
            end

            def checkAndDelete(table, row, family, qualifier, value, tdelete)
              send_checkAndDelete(table, row, family, qualifier, value, tdelete)
              return recv_checkAndDelete()
            end

            def send_checkAndDelete(table, row, family, qualifier, value, tdelete)
              send_message('checkAndDelete', CheckAndDelete_args, :table => table, :row => row, :family => family, :qualifier => qualifier, :value => value, :tdelete => tdelete)
            end

            def recv_checkAndDelete()
              result = receive_message(CheckAndDelete_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'checkAndDelete failed: unknown result')
            end

            def increment(table, tincrement)
              send_increment(table, tincrement)
              return recv_increment()
            end

            def send_increment(table, tincrement)
              send_message('increment', Increment_args, :table => table, :tincrement => tincrement)
            end

            def recv_increment()
              result = receive_message(Increment_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'increment failed: unknown result')
            end

            def append(table, tappend)
              send_append(table, tappend)
              return recv_append()
            end

            def send_append(table, tappend)
              send_message('append', Append_args, :table => table, :tappend => tappend)
            end

            def recv_append()
              result = receive_message(Append_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'append failed: unknown result')
            end

            def openScanner(table, tscan)
              send_openScanner(table, tscan)
              return recv_openScanner()
            end

            def send_openScanner(table, tscan)
              send_message('openScanner', OpenScanner_args, :table => table, :tscan => tscan)
            end

            def recv_openScanner()
              result = receive_message(OpenScanner_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'openScanner failed: unknown result')
            end

            def getScannerRows(scannerId, numRows)
              send_getScannerRows(scannerId, numRows)
              return recv_getScannerRows()
            end

            def send_getScannerRows(scannerId, numRows)
              send_message('getScannerRows', GetScannerRows_args, :scannerId => scannerId, :numRows => numRows)
            end

            def recv_getScannerRows()
              result = receive_message(GetScannerRows_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getScannerRows failed: unknown result')
            end

            def closeScanner(scannerId)
              send_closeScanner(scannerId)
              recv_closeScanner()
            end

            def send_closeScanner(scannerId)
              send_message('closeScanner', CloseScanner_args, :scannerId => scannerId)
            end

            def recv_closeScanner()
              result = receive_message(CloseScanner_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              return
            end

            def mutateRow(table, trowMutations)
              send_mutateRow(table, trowMutations)
              recv_mutateRow()
            end

            def send_mutateRow(table, trowMutations)
              send_message('mutateRow', MutateRow_args, :table => table, :trowMutations => trowMutations)
            end

            def recv_mutateRow()
              result = receive_message(MutateRow_result)
              raise result.io unless result.io.nil?
              return
            end

            def getScannerResults(table, tscan, numRows)
              send_getScannerResults(table, tscan, numRows)
              return recv_getScannerResults()
            end

            def send_getScannerResults(table, tscan, numRows)
              send_message('getScannerResults', GetScannerResults_args, :table => table, :tscan => tscan, :numRows => numRows)
            end

            def recv_getScannerResults()
              result = receive_message(GetScannerResults_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getScannerResults failed: unknown result')
            end

            def getRegionLocation(table, row, reload)
              send_getRegionLocation(table, row, reload)
              return recv_getRegionLocation()
            end

            def send_getRegionLocation(table, row, reload)
              send_message('getRegionLocation', GetRegionLocation_args, :table => table, :row => row, :reload => reload)
            end

            def recv_getRegionLocation()
              result = receive_message(GetRegionLocation_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRegionLocation failed: unknown result')
            end

            def getAllRegionLocations(table)
              send_getAllRegionLocations(table)
              return recv_getAllRegionLocations()
            end

            def send_getAllRegionLocations(table)
              send_message('getAllRegionLocations', GetAllRegionLocations_args, :table => table)
            end

            def recv_getAllRegionLocations()
              result = receive_message(GetAllRegionLocations_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getAllRegionLocations failed: unknown result')
            end

          end

          class Processor
            include ::Thrift::Processor

            def process_exists(seqid, iprot, oprot)
              args = read_args(iprot, Exists_args)
              result = Exists_result.new()
              begin
                result.success = @handler.exists(args.table, args.tget)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'exists', seqid)
            end

            def process_get(seqid, iprot, oprot)
              args = read_args(iprot, Get_args)
              result = Get_result.new()
              begin
                result.success = @handler.get(args.table, args.tget)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'get', seqid)
            end

            def process_getMultiple(seqid, iprot, oprot)
              args = read_args(iprot, GetMultiple_args)
              result = GetMultiple_result.new()
              begin
                result.success = @handler.getMultiple(args.table, args.tgets)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'getMultiple', seqid)
            end

            def process_put(seqid, iprot, oprot)
              args = read_args(iprot, Put_args)
              result = Put_result.new()
              begin
                @handler.put(args.table, args.tput)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'put', seqid)
            end

            def process_checkAndPut(seqid, iprot, oprot)
              args = read_args(iprot, CheckAndPut_args)
              result = CheckAndPut_result.new()
              begin
                result.success = @handler.checkAndPut(args.table, args.row, args.family, args.qualifier, args.value, args.tput)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'checkAndPut', seqid)
            end

            def process_putMultiple(seqid, iprot, oprot)
              args = read_args(iprot, PutMultiple_args)
              result = PutMultiple_result.new()
              begin
                @handler.putMultiple(args.table, args.tputs)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'putMultiple', seqid)
            end

            def process_deleteSingle(seqid, iprot, oprot)
              args = read_args(iprot, DeleteSingle_args)
              result = DeleteSingle_result.new()
              begin
                @handler.deleteSingle(args.table, args.tdelete)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteSingle', seqid)
            end

            def process_deleteMultiple(seqid, iprot, oprot)
              args = read_args(iprot, DeleteMultiple_args)
              result = DeleteMultiple_result.new()
              begin
                result.success = @handler.deleteMultiple(args.table, args.tdeletes)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteMultiple', seqid)
            end

            def process_checkAndDelete(seqid, iprot, oprot)
              args = read_args(iprot, CheckAndDelete_args)
              result = CheckAndDelete_result.new()
              begin
                result.success = @handler.checkAndDelete(args.table, args.row, args.family, args.qualifier, args.value, args.tdelete)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'checkAndDelete', seqid)
            end

            def process_increment(seqid, iprot, oprot)
              args = read_args(iprot, Increment_args)
              result = Increment_result.new()
              begin
                result.success = @handler.increment(args.table, args.tincrement)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'increment', seqid)
            end

            def process_append(seqid, iprot, oprot)
              args = read_args(iprot, Append_args)
              result = Append_result.new()
              begin
                result.success = @handler.append(args.table, args.tappend)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'append', seqid)
            end

            def process_openScanner(seqid, iprot, oprot)
              args = read_args(iprot, OpenScanner_args)
              result = OpenScanner_result.new()
              begin
                result.success = @handler.openScanner(args.table, args.tscan)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'openScanner', seqid)
            end

            def process_getScannerRows(seqid, iprot, oprot)
              args = read_args(iprot, GetScannerRows_args)
              result = GetScannerRows_result.new()
              begin
                result.success = @handler.getScannerRows(args.scannerId, args.numRows)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'getScannerRows', seqid)
            end

            def process_closeScanner(seqid, iprot, oprot)
              args = read_args(iprot, CloseScanner_args)
              result = CloseScanner_result.new()
              begin
                @handler.closeScanner(args.scannerId)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'closeScanner', seqid)
            end

            def process_mutateRow(seqid, iprot, oprot)
              args = read_args(iprot, MutateRow_args)
              result = MutateRow_result.new()
              begin
                @handler.mutateRow(args.table, args.trowMutations)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'mutateRow', seqid)
            end

            def process_getScannerResults(seqid, iprot, oprot)
              args = read_args(iprot, GetScannerResults_args)
              result = GetScannerResults_result.new()
              begin
                result.success = @handler.getScannerResults(args.table, args.tscan, args.numRows)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'getScannerResults', seqid)
            end

            def process_getRegionLocation(seqid, iprot, oprot)
              args = read_args(iprot, GetRegionLocation_args)
              result = GetRegionLocation_result.new()
              begin
                result.success = @handler.getRegionLocation(args.table, args.row, args.reload)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRegionLocation', seqid)
            end

            def process_getAllRegionLocations(seqid, iprot, oprot)
              args = read_args(iprot, GetAllRegionLocations_args)
              result = GetAllRegionLocations_result.new()
              begin
                result.success = @handler.getAllRegionLocations(args.table)
              rescue ::Apache::Hadoop::Hbase::Thrift2::TIOError => io
                result.io = io
              end
              write_result(result, oprot, 'getAllRegionLocations', seqid)
            end

          end

          # HELPER FUNCTIONS AND STRUCTURES

          class Exists_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TGET = 2

            FIELDS = {
              # the table to check on
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TGet to check for
              TGET => {:type => ::Thrift::Types::STRUCT, :name => 'tget', :class => ::Apache::Hadoop::Hbase::Thrift2::TGet}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tget is unset!') unless @tget
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Exists_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Get_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TGET = 2

            FIELDS = {
              # the table to get from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TGet to fetch
              TGET => {:type => ::Thrift::Types::STRUCT, :name => 'tget', :class => ::Apache::Hadoop::Hbase::Thrift2::TGet}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tget is unset!') unless @tget
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Get_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Apache::Hadoop::Hbase::Thrift2::TResult},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetMultiple_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TGETS = 2

            FIELDS = {
              # the table to get from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # a list of TGets to fetch, the Result list
# will have the Results at corresponding positions
# or null if there was an error
              TGETS => {:type => ::Thrift::Types::LIST, :name => 'tgets', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TGet}}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tgets is unset!') unless @tgets
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetMultiple_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Put_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TPUT = 2

            FIELDS = {
              # the table to put data in
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TPut to put
              TPUT => {:type => ::Thrift::Types::STRUCT, :name => 'tput', :class => ::Apache::Hadoop::Hbase::Thrift2::TPut}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tput is unset!') unless @tput
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Put_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndPut_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            ROW = 2
            FAMILY = 3
            QUALIFIER = 4
            VALUE = 5
            TPUT = 6

            FIELDS = {
              # to check in and put to
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # row to check
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column family to check
              FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family', :binary => true},
              # column qualifier to check
              QUALIFIER => {:type => ::Thrift::Types::STRING, :name => 'qualifier', :binary => true},
              # the expected value, if not provided the
# check is for the non-existence of the
# column in question
              VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true},
              # the TPut to put if the check succeeds
              TPUT => {:type => ::Thrift::Types::STRUCT, :name => 'tput', :class => ::Apache::Hadoop::Hbase::Thrift2::TPut}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field row is unset!') unless @row
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field family is unset!') unless @family
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field qualifier is unset!') unless @qualifier
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tput is unset!') unless @tput
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndPut_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class PutMultiple_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TPUTS = 2

            FIELDS = {
              # the table to put data in
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # a list of TPuts to commit
              TPUTS => {:type => ::Thrift::Types::LIST, :name => 'tputs', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TPut}}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tputs is unset!') unless @tputs
            end

            ::Thrift::Struct.generate_accessors self
          end

          class PutMultiple_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteSingle_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TDELETE = 2

            FIELDS = {
              # the table to delete from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TDelete to delete
              TDELETE => {:type => ::Thrift::Types::STRUCT, :name => 'tdelete', :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tdelete is unset!') unless @tdelete
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteSingle_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteMultiple_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TDELETES = 2

            FIELDS = {
              # the table to delete from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # list of TDeletes to delete
              TDELETES => {:type => ::Thrift::Types::LIST, :name => 'tdeletes', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tdeletes is unset!') unless @tdeletes
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteMultiple_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndDelete_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            ROW = 2
            FAMILY = 3
            QUALIFIER = 4
            VALUE = 5
            TDELETE = 6

            FIELDS = {
              # to check in and delete from
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # row to check
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column family to check
              FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family', :binary => true},
              # column qualifier to check
              QUALIFIER => {:type => ::Thrift::Types::STRING, :name => 'qualifier', :binary => true},
              # the expected value, if not provided the
# check is for the non-existence of the
# column in question
              VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :binary => true},
              # the TDelete to execute if the check succeeds
              TDELETE => {:type => ::Thrift::Types::STRUCT, :name => 'tdelete', :class => ::Apache::Hadoop::Hbase::Thrift2::TDelete}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field row is unset!') unless @row
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field family is unset!') unless @family
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field qualifier is unset!') unless @qualifier
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tdelete is unset!') unless @tdelete
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CheckAndDelete_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Increment_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TINCREMENT = 2

            FIELDS = {
              # the table to increment the value on
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TIncrement to increment
              TINCREMENT => {:type => ::Thrift::Types::STRUCT, :name => 'tincrement', :class => ::Apache::Hadoop::Hbase::Thrift2::TIncrement}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tincrement is unset!') unless @tincrement
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Increment_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Apache::Hadoop::Hbase::Thrift2::TResult},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Append_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TAPPEND = 2

            FIELDS = {
              # the table to append the value on
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the TAppend to append
              TAPPEND => {:type => ::Thrift::Types::STRUCT, :name => 'tappend', :class => ::Apache::Hadoop::Hbase::Thrift2::TAppend}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tappend is unset!') unless @tappend
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Append_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Apache::Hadoop::Hbase::Thrift2::TResult},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class OpenScanner_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TSCAN = 2

            FIELDS = {
              # the table to get the Scanner for
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the scan object to get a Scanner for
              TSCAN => {:type => ::Thrift::Types::STRUCT, :name => 'tscan', :class => ::Apache::Hadoop::Hbase::Thrift2::TScan}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tscan is unset!') unless @tscan
            end

            ::Thrift::Struct.generate_accessors self
          end

          class OpenScanner_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetScannerRows_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SCANNERID = 1
            NUMROWS = 2

            FIELDS = {
              # the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
              SCANNERID => {:type => ::Thrift::Types::I32, :name => 'scannerId'},
              # number of rows to return
              NUMROWS => {:type => ::Thrift::Types::I32, :name => 'numRows', :default => 1}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scannerId is unset!') unless @scannerId
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetScannerRows_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1
            IA = 2

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError},
              # if the scannerId is invalid
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CloseScanner_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SCANNERID = 1

            FIELDS = {
              # the Id of the Scanner to close *
              SCANNERID => {:type => ::Thrift::Types::I32, :name => 'scannerId'}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scannerId is unset!') unless @scannerId
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CloseScanner_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError},
              # if the scannerId is invalid
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift2::TIllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRow_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TROWMUTATIONS = 2

            FIELDS = {
              # table to apply the mutations
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # mutations to apply
              TROWMUTATIONS => {:type => ::Thrift::Types::STRUCT, :name => 'trowMutations', :class => ::Apache::Hadoop::Hbase::Thrift2::TRowMutations}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field trowMutations is unset!') unless @trowMutations
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRow_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetScannerResults_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            TSCAN = 2
            NUMROWS = 3

            FIELDS = {
              # the table to get the Scanner for
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              # the scan object to get a Scanner for
              TSCAN => {:type => ::Thrift::Types::STRUCT, :name => 'tscan', :class => ::Apache::Hadoop::Hbase::Thrift2::TScan},
              # number of rows to return
              NUMROWS => {:type => ::Thrift::Types::I32, :name => 'numRows', :default => 1}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field tscan is unset!') unless @tscan
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetScannerResults_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::TResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRegionLocation_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1
            ROW = 2
            RELOAD = 3

            FIELDS = {
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true},
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              RELOAD => {:type => ::Thrift::Types::BOOL, :name => 'reload'}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field row is unset!') unless @row
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRegionLocation_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Apache::Hadoop::Hbase::Thrift2::THRegionLocation},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetAllRegionLocations_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLE = 1

            FIELDS = {
              TABLE => {:type => ::Thrift::Types::STRING, :name => 'table', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
              raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field table is unset!') unless @table
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetAllRegionLocations_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift2::THRegionLocation}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift2::TIOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

        end

      end
    end
  end
end
